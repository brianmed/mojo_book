\documentclass[14pt]{extreport}
\usepackage[left=0.5in, right=0.5in, top=1.0in, bottom=1.0in]{geometry}
\usepackage{layout}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{textcomp}
\usepackage{pslatex}	    % to use PostScript fonts
\usepackage{parskip}
\usepackage{wasysym}
\usepackage[scaled]{beramono}
\usepackage[]{microtype}

\newcommand\Small{\fontsize{10}{10.2}\selectfont}
\newcommand*\LSTfont{\Small\ttfamily\SetTracking{encoding=*}{-60}\lsstyle}

\DeclareSymbolFont{extraup}{U}{zavm}{m}{n}
\DeclareMathSymbol{\varheart}{\mathalpha}{extraup}{86}
\DeclareMathSymbol{\vardiamond}{\mathalpha}{extraup}{87}

\lstdefinestyle{BashInputStyle}{
  language=bash,
  basicstyle=\LSTfont,
  numbers=none,
  frame=none,
  columns=fullflexible,
  linewidth=1.0\linewidth,
  xleftmargin=0.0\linewidth,
  xrightmargin=0.0\linewidth,
  literate={-}{\textminus}{1}
}

\lstdefinestyle{BashOutputStyle}{
  basicstyle=\LSTfont,
  numbers=none,
  frame=tblr,
  columns=fullflexible,
  backgroundcolor=\color{blue!10},
  linewidth=1.0\linewidth,
  xleftmargin=0.0\linewidth,
  xrightmargin=0.0\linewidth
}

\lstdefinestyle{BlockStyle}{
  basicstyle=\LSTfont,
  numbers=none,
  frame=none,
  columns=fullflexible,
  linewidth=1.0\linewidth,
  xleftmargin=0.0\linewidth,
  xrightmargin=0.0\linewidth
}

\lstdefinestyle{CodeStyle}{
  basicstyle=\LSTfont,
  keywordstyle=\color{black}\bfseries\underbar,
  frame=none,
  escapeinside={(*@}{@*)},
  stringstyle=\ttfamily, 
  showstringspaces=false,
  numbers=left
}

\lstset{% general command to set parameter(s) 
basicstyle=\small, % print whole listing small 
keywordstyle=\color{black}\bfseries\underbar,
frame=none,
literate=%
          {♥}{{$\varheart$}}{1}
          {‹}{{\LEFTarrow}}{1}
          {›}{{\RIGHTarrow}}{1},
escapeinside={(*@}{@*)},
stringstyle=\ttfamily, 
showstringspaces=false,
numbers=left}

\begin{document}

\title{Get some Mojo}
\author{Brian Medley}

\maketitle
\tableofcontents

\chapter*{License}
\markboth{\MakeUppercase{License}}{}
\addcontentsline{toc}{chapter}{License}

Please download and share this book unmodified. (The book is avalible under a
Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.)

https://creativecommons.org/licenses/by-nc-nd/3.0/

\chapter*{Rationale}
\markboth{\MakeUppercase{Rationale}}{}
\addcontentsline{toc}{chapter}{Rationale}

\section{Mojolicious}

Thus begins our quest for Mojo - a tutorial approach to learning web
technologies. We will be learning Mojolicious [http://mojolicious.org]; at the
time of this writing it is a "next generation web framework for the Perl
Programming language".

From chapters 2 to the end we will be building a Photo album application. What
does next generation mean? It is a MVC framework that includes:

\begin{itemize} \itemsep1pt \parskip0pt \parsep0pt
\item \verb|Full stack HTTP and WebSocket client/server.|
\item \verb|IPv6, TLS, SNI, IDNA, Comet|
\item \verb|Non-blocking I/O and embeddable web server|
\item \verb|JSON and HTML/XML parse with CSS selectors|
\item \verb|Templates|
\item \verb|Sessions|
\item \verb|Cookie management|
\item \verb|HTTP / WebSocket|
\item \verb|Routes|
\item \verb|CGI / PSGI auto-detection|
\item \verb|Static files|
\item \verb|Testing framework|
\item \verb|Plugins|
\end{itemize}

\chapter*{Preparation}
\markboth{\MakeUppercase{Preparation}}{}
\addcontentsline{toc}{chapter}{Preparation}

{\Large Perl}

Mojolicious requires Perl.  We will be using Perl on Linux with 5.20.1.  Your
system perl is probably a lower version, so we will bootstrap our install with 
Perl-Build and App::cpanminus.

\begin{lstlisting}[style=BashInputStyle]
$ curl -L -n -O https://raw.github.com/.../perl-build
$ perl perl-build 5.20.1 /opt/perl-5.20.1
\end{lstlisting}

\begin{lstlisting}[style=BashOutputStyle]
Fetching 5.20.1 ...
Downloaded http://.../SHAY/perl-5.20.1.tar.bz2 to .../perl-5.20.1.tar.bz2
Configuring perl '5.20.1'
...
\end{lstlisting}

\begin{lstlisting}[style=BashInputStyle]
$ curl -L http://cpanmin.us | /opt/perl-5.20.1/perl - App::cpanminus
\end{lstlisting}

\begin{lstlisting}[style=BashOutputStyle]
--> Working on App::cpanminus
Fetching http://www.cpan.org/authors/id/M/MI/MIYAGAWA/App-cpanminus-1.7014.tar.gz ... OK
Configuring App-cpanminus-1.7014 ... OK
...
Building and testing App-cpanminus-1.7014 ... OK
Successfully installed App-cpanminus-1.7014
3 distributions installed
\end{lstlisting}

After doing these things it will be easier to install Mojolicious and any required modules.
Also, there is now a fully functional perl install that can be tinkered with to your heart's content.
To verify the install run:

\begin{lstlisting}[style=BashInputStyle]
$ /opt/perl-5.20.1/bin/perl -v
\end{lstlisting}

\begin{lstlisting}[style=BashOutputStyle]
This is perl 5, version 20, subversion 1 (v5.20.1) built for darwin-2level

Copyright 1987-2014, Larry Wall

Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.

Complete documentation for Perl, including FAQ lists, should be found on
this system using "man perl" or "perldoc perl".  If you have access to the
Internet, point your browser at http://www.perl.org/, the Perl Home Page.
\end{lstlisting}

For convience, a symlink can be added so that /opt/perl points to
/opt/perl/5.20.1/bin/perl.

\begin{lstlisting}[style=BashInputStyle]
$ ln -s /opt/perl-5.20.1/bin/perl /opt/perl
\end{lstlisting}

{\Large Installallation}

Adding the CPAN module to the system installs everything needed for
Mojolicious. 

\begin{lstlisting}[style=BashInputStyle]
$ /opt/perl-5.20.1/bin/cpanm Mojolicious
\end{lstlisting}

\begin{lstlisting}[style=BashOutputStyle]
...
Mojolicious will be installed by the cpanm utility.
\end{lstlisting}

{\Large Hello World In Text}

Now that we have Mojolicious installed, we can start writing code for our
website. Our first example is a full program and you are not expected to
understand everything. It is geared to get your feet wet. After this, we will
be a tutorial introduction into HTTP, HTML, Javascript, CSS, and other Web
technologies.  Our first example is a Mojolicious::Lite application. It is a
Real-time micro web framework. This micro web framework can have the entire web
structure in a file.

\lstinputlisting[language=Perl, style=CodeStyle]{hello_world_text.pl}

Line \ref{_ex1_1_use} turns your perl script into a full featured web
application, that uses strict, warnings, utf8 and Perl 5.10 features. It's fun.

Run the program like so:

\begin{lstlisting}[style=BashInputStyle]
$ morbo -v hello_worl.pl
\end{lstlisting}

\begin{lstlisting}[style=BashOutputStyle]
["Mon Sep 3 19:08:38 2012] [info] Listening at "http://*:3000".
Server available at http://127.0.0.1:3000."
\end{lstlisting}

We now have a full featured web server running on port 3000. You may view in
any browser. In your URL bar put: http://127.0.0.1:3000 and view the page.

{\Large Hello World In HTML}

Next, modify the contents of hello\_world.pl to look like this:

\lstinputlisting[language=Perl, style=CodeStyle]{hello_world_html.pl}

Our morbo server should automatically restart and load the new file contents.  The code
at line \ref{_ex1_2_render} display the inlined page below.

Next, add Carpe diem after line \ref{_ex1_2_add_line_here}. Save the file and
reload the page in the browser. The morbo server will restart your server once
a change is made.

The other way to build an app is with a well-structured web application. This
is where the business logic and application setup are put in several files, as
opposed to just one.  A full app is created with the "generate app" command and
an example is below.

\begin{lstlisting}[style=BashInputStyle]
$ mojo generate app Example           
\end{lstlisting}

\begin{lstlisting}[style=BashOutputStyle]
  [mkdir] /private/tmp/example/script
  [write] /private/tmp/example/script/example
  [chmod] /private/tmp/example/script/example 744
  [mkdir] /private/tmp/example/lib
  [write] /private/tmp/example/lib/Example.pm
  [mkdir] /private/tmp/example/lib/Example/Controller
  [write] /private/tmp/example/lib/Example/Controller/Example.pm
  [mkdir] /private/tmp/example/t
  [write] /private/tmp/example/t/basic.t
  [mkdir] /private/tmp/example/log
  [mkdir] /private/tmp/example/public
  [write] /private/tmp/example/public/index.html
  [mkdir] /private/tmp/example/templates/layouts
  [write] /private/tmp/example/templates/layouts/default.html.ep
  [mkdir] /private/tmp/example/templates/example
  [write] /private/tmp/example/templates/example/welcome.html.ep
\end{lstlisting}

As you can see, it has a invocation script, startup package (lib/Example.pm),
an example Controller, some tests, and example content (the index.html and .ep
template files).

We are going to be using lite apps going forward until the photo album is
encountered later on.

\chapter*{Going Forward}
\markboth{\MakeUppercase{Going Forward}}{}
\addcontentsline{toc}{chapter}{Going Forward}

\section{Preamble}

Here we get down with Mojo.  A brief introduction of HTTP 1.1 is given and then
we look at some specific ways that Mojolicious creates a framework around
web technologies to make things easier for development.  Specifically, we will look
at Routes, Logging, GET/POST Parameters, Templates, and Sessions.

After that our attention will be turned to a Photo album app.

\section{HTTP 1.1}

{\Large Under the Hood}

As you know, web pages are loaded from a server. When you goto domain.com, then
the default HTML is loaded using HTTP.  As you will see, the transfer, or
request, from the server to your web browser client can be considered a file
transfer. For example, when http://127.0.0.1:3000 was visited something like
the following was sent from your browser to the server:

\begin{lstlisting}[style=BlockStyle]
    GET / HTTP/1.1
    Host: 127.0.0.1:3000
    Connection: keep-alive
    Cache-Control: max-age=0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHT
    Accept-Encoding: gzip,deflate,sdch
    Accept-Language: en-US,en;q=0.8
\end{lstlisting}

Then, the server responded with:

\begin{lstlisting}[style=BlockStyle]
    HTTP/1.1 200 OK
    Content-Length: 2
    Server: Mojolicious (Perl)
    Connection: keep-alive
    Date: Wed, 30 Oct 2013 23:44:04 GMT
    Content-Type: text/html;charset=UTF-8
\end{lstlisting}

If we were to goto http://127.0.0.1:3000/hello, then the GET request would
start with:

\begin{lstlisting}[style=BlockStyle]
    GET /hello HTTP 1.1
\end{lstlisting}

Of note, is that when we access http://127.0.0.1:3000 there is an implied "/"
and when http://127.0.0.1:3000/hello there is a specific "/hello".  These are
the pages that the server is being requested to serve.

\section{Routes}

{\Large Finding our way}

Routes enable Mojolicious to easily glue together an incoming request with
code.

From the Mojolicious::Lite perldoc:

Routes are basically just fancy paths that can contain different kinds of
placeholders.

For example, given the code below:

\lstinputlisting[basicstyle=\LSTfont, language=Perl]{routes.pl}

The \textbf{get '/foo'} will redirect a \textbf{HTTP GET /foo} request to the anonymous
subroutine listed. It should be noted that a GET and POST can be redirected to
a different subroutine.  This is a very powerful construct that allows us to
execute arbitrary business logic (system commands, SQL, control flow logic,
etc) for a given request.

Also, \$self is a Mojolicious::Controller object containing both, the HTTP
request and response.

\begin{center}
  \begin{tabular}{|l|r|}
    \hline
    GET  & CODE\\
    \hline
    GET /foo & \ref{_ex2_1_get}: get "/foo" => sub {}\\
    POST /foo & \ref{_ex2_1_post}: post "/foo" => sub {}\\
    \hline
  \end{tabular}
\end{center}

{\Large Extending hello\_world.pl}

It would be nice to be able to click and get different "page" from web server
that gave us feedback. We will use the internal templating system called
Embedded Perl.

\lstinputlisting[basicstyle=\LSTfont, language=Perl]{ex2_2.pl}

Once ran via morbo we can click the "carpe" link and get dynamic feedback from our web server.

\section{Logging}

{\Large From whence we came}

At times it is appropriate to log data while processing a code in the backend.
In development mode a file in \textbf{log}/development.log is used and in production
mode a file \textbf{log}/production.log is utilized. The modes can be switched around
via \textit{MOJO\_MODE} environment variable. Merely creating a log directory will enable
the output into these files.

\begin{lstlisting}[style=BashInputStyle]
$ mkdir log
\end{lstlisting}

Now we can send logging data to the proper file with code such as:

\verbatiminput{ex2_3.pl}

In addition, usage statistics for each request are logged to the
development.log file.  For example, the below is from the route snippet above.

\begin{lstlisting}[style=BashOutputStyle]
    [Mon Sep  3 22:07:35 2012] [info] Listening at "http://*:3000".
    [Mon Sep  3 22:07:38 2012] [debug] Your secret passphrase needs to be changed!!!
    [Mon Sep  3 22:07:38 2012] [debug] GET /carpe (Mozilla/5.0 (X11; Linux x86\_64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1).
    [Mon Sep  3 22:07:38 2012] [debug] Routing to a callback.
    [Mon Sep  3 22:07:38 2012] [debug] {
      'now' => 'Mon Sep  3 22:07:38 2012'
    }
\end{lstlisting}

\section{Parameters}

{\Large Variety is the spice...}

Input and output are intrinsic to any computer program, perhaps doubly so to a
web application.  A significant source of user input comes from GET and POST
parameters.

These parameters present themselves through the requests and
responses the web server and client make.  They can be in href URLs, forms, and
javascript code.

As a specific example, the following code can be used to
demonstrate a POST action that logs a user in.  The parameter is the username -
there is no password, not very secure.

\lstinputlisting[basicstyle=\LSTfont, language=Perl]{ex2_3.pl}

The application usage is straightforward: run the program and then enter your
username followed by a return.  You should then be logged in.

The parameter "name" is an agreement between the view and the controller.
Before you're logged in there is html that presents a form and the form is sent
back to the server in the form of a POST request.  This request is processed
and the "param" method exposes the data to the application - using the "name"
argument.  "name" is common between the form, the POST request, and the
application.

\section{Templates and Stash}

{\Large How did that get there?}

Templates are the bread and butter of dynamic content generation.  They take
input from the controller and load that into a templating system to create
content.  The content is usually a web page with HTML, CSS, and Javascript.
However, there are other possibilites, as well, such as text.

The input from the controller is placed in a "stash" data structure.  There are
a few ways to setup this data structure.  One approach is to use the "stash"
controller method.

\lstinputlisting[basicstyle=\LSTfont, language=Perl]{ex2_4.pl}

For example, in line \ref{_ex2_4_stash} of ex2\_4.pl we set the "name" stash 
parameter which will be available in the templates.  Specifically, at line 
\ref{_ex2_4_stash_usage} the "stash" helper is used to dynamically adjust
the template output.

\chapter*{Mojolicious Applications}
\markboth{\MakeUppercase{Mojolicious Applications}}{}
\addcontentsline{toc}{chapter}{Mojolicious Applications}

\section{A Photo app}

The previous portion of this book focused on Mojolicious::Lite applications;
however, in order to realize our Photo application it will be easier to use the
full blown application features of Mojolicious.  An application of this type
can be started with:

\begin{lstlisting}[style=BashInputStyle]
$ mojo generate app Photo
\end{lstlisting}

However, we are going to use the git checkout of this book which includes all the 
code for our Photo app.

\begin{lstlisting}[style=BashOutputStyle]
$ cd /opt
$ git clone git@github.com:brianmed/mojo_book.git
\end{lstlisting}

The app is runable via:

\begin{lstlisting}[style=BashInputStyle]
$ cd photo
$ morbo -v script/photo
\end{lstlisting}

When we point our browser to http://localhost:3000 we'll get our app.  As you
can see, our version is in /opt/mojo\_book/photo and expects its config file to
be in /opt/photo.  See the apppendix for a config file example.

After the config file has been setup, we can run our app via "script/photo";
this is a perl script that bootstraps our app.  Most of the time you won't need
to modify this; however, if module directories are needed, then "use lib" statements
can be put here.

What happens next?

{\Large Startup}

Mojolicious initializes our app and then calls Photo::startup.

The startup method adds, configures plugins; sets up some logging; adds in
helpers; and sets up routes.  For example, as you can see below in the line from
lib/Photo.pm our route for the index page is setup.

\lstinputlisting[basicstyle=\LSTfont, language=Perl, numbers=none, firstline=35, lastline=35]{photo/lib/Photo.pm}

When a user agent does a GET /, then Photo::Controller::Index::slash will be
called and the slash.html.ep file will be served.

\lstinputlisting[basicstyle=\LSTfont, language=Perl, firstline=8, lastline=13]{photo/lib/Photo/Controller/Index.pm}

Given that, lets go back and discet Photo::startup one "section" at a time.

First, we turn on development logging for when we are running in production
mode.  This is a convience for early stage production or when debugging
something.  Simply comment out for Production.  Next, we initialize the
config data structure with a file.  These are lines 1 and 3 below.

\lstinputlisting[basicstyle=\LSTfont, language=Perl, firstline=8, lastline=10]{photo/lib/Photo.pm}

This file is just a perl data structure and can be hand edited or
programmatically defined.  Another option is to use JSCONConfig and a JSON
config file.  Below is an example config file.

\lstinputlisting[basicstyle=\LSTfont]{photo.config}

The next setup phase is to initialize the secret passphrase.  Multiple
passphrases are supported to allow for phasing out an old passphrase.  These
passphrases are used for things like signed cookies (which are used in the
sessions).

\lstinputlisting[basicstyle=\LSTfont, language=Perl, numbers=none, firstline=12, lastline=12]{photo/lib/Photo.pm}

% TODO use a database helper

%%% After our secret passphrases we setup the helpers.  A helper is a sub that is
%%% made available to the controller object and the application object, as well as
%%% a function in ep templates.  There are two helpers defined and then
%%% initialized.
%%% 
%%% \lstinputlisting[basicstyle=\LSTfont, language=Perl, firstline=26, lastline=29]{photo/lib/Photo.pm}
%%% 
%%% The next piece setup is hypnotoad and we will defer that till we talk about
%%% deployment.

After our passphrase we setup our routes; an "under" nested route that verifies
the session; and route setup itself.  At line 15 the "entry" point to our app
from the user agent is defined - namely the initial page.  It should be noted
that we can define "get" and "post" for these routes.  

\lstinputlisting[basicstyle=\LSTfont, language=Perl, firstline=21, lastline=35]{photo/lib/Photo.pm}

Arbitrary perl (DB lookups, JSON parsing, file processing) can be put in the
nested route and if "1" is returned the child route will be allowed to run
"undef" and it won't.  Very handy for doing basic authentication and
authorization checks.  If they don't pass either one, then a redirect can
happen, or some flag can be set.

In addition "any" is supported - which is useful for supporting GET and POST on
the same route.

\lstinputlisting[basicstyle=\LSTfont, language=Perl, firstline=37, lastline=49]{photo/lib/Photo.pm}

One thing that should be mentioned about our routes is that they have two modes of
operation.  One is when we have no session and another is when there is a session.
Our session stores the selected album and the \$have\_album nested route verifies
if the session is still valid.. if not, the user agent will be redirected back to the
landing page.  The code is below.

\lstinputlisting[basicstyle=\LSTfont, language=Perl, firstline=51, lastline=62]{photo/lib/Photo.pm}

{\Large Controller}

A controller encapsulates the business logic for our website.  Fine grained
control can be exerted over the app by using pacakages and subs.  One package
can control the "main" page with login and logout and other packages can focus
on other sub systems of our app.

For our app, we have the Index and Album controllers.  One is the landing page for
our app and the other holds all the business logic for the photo album.

We can view an album, create one, switch to a new album, upload a photo, and
view a photo.

{\Large Landing Page}

The main page does several things - allow for viewing; selecting, or creating
an album.  Below is the method responsible for all this.

\lstinputlisting[basicstyle=\LSTfont, language=Perl, firstline=8, lastline=30]{photo/lib/Photo/Controller/Index.pm}

Code starting at line 4 checks to see if any albums have been created; if not,
the user is redirected to /album/create.  In addition, we're using the handy
url\_for and redirect\_to methods. These methods allow for more easily working
with URLs and generating a 302 response.

One last thing, is that this switch-a-roo logic is made possible by the
marvelous session handling in Mojolicious.  There are several ways to use the
session, two are detailed below.  The first line reads a variable from the
session and the second line sets the variable.

\begin{lstlisting}[style=BlockStyle]
    my $foo     = $c->session('foo');
    $c          = $c->session(foo => 'bar');
\end{lstlisting}

That's all you got to do, and you get:

\begin{lstlisting}[style=BlockStyle]
    Persistent data storage for the next few requests, all session data gets
    serialized with Mojo::JSON and stored Base64 encoded in HMAC-SHA1 signed
    cookies, to prevent tampering. Note that cookies usually have a 4096 byte (4KB)
    limit, depending on browser.
\end{lstlisting}

{\Large Photo}

Initialy, no photo albums exist in the model.

Given that, the landing page redirects the user to an action that creates an
album.  This action is not in Photo::Controller::Album, it uses automatic
rendering (explained below).

\begin{lstlisting}[style=BlockStyle]
    The renderer can be manually started by calling the method "render" in
    Mojolicious::Controller, but that's usually not necessary, because it will get
    automatically called if nothing has been rendered after the router finished its
    work. This also means you can have routes pointing only to templates without
    actual actions.
\end{lstlisting}

This automated rendering takes our template file and displays it.  The template
name is generated by taking the controller, action, format, and handler and
combining them like so: controller/action.format.handler.  Therefore, our
template is album/create.html.ep.

The main things to note in this template are the error and form handling.  The
error section is here:

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Html, firstline=13, lastline=24]{photo/templates/album/create.html.ep}

The main points are the \% to embed perl code in the template sandbox and the
flash usage.  The flash is persistent for one-request only and is stored in the
session.  The error would come from the POST form action (shown below).

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Html, firstline=29, lastline=29]{photo/templates/album/create.html.ep}

The POST action Album::Controller::save does several things, most notably it
validates the input, creates the album, and stores the album name in the session. 
That is, it "switches" to that album. Below is the erorr handling.  Of note is that
the flash error value is stored with an API similar to the stash.  After setting our
error flag we redirect back to displaying the create view.

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Perl, firstline=27, lastline=35]{photo/lib/Photo/Controller/Album.pm}

After the input checks are done and the album created, we switch to that album
and redirect back to the landing page - while will detect that a selected album
and act appropriately.

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Perl, firstline=53, lastline=57]{photo/lib/Photo/Controller/Album.pm}

Also, one thing to see that we have a "warn" in the code there. It's main
purpose is to show that this is possible and will go the "console". For
example, if running through morbo, then the message will be intermixed in the 
morbo output and not in the log file.

So, after the above, we go back to the landing page - which redirects to the
album viewer.  The action for this is Photo::Controller::Album::show. This sub
is responsible for shimmying data from our model (a bunch of JSON files) to the
view.  Below is how that is accomplished.

It should be noted that we are able to pass an object to the view.

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Perl, firstline=17, lastline=19]{photo/lib/Photo/Controller/Album.pm}

In addition, we put some debug information in the log to demonstrate how that
operates.

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Perl, firstline=15, lastline=15]{photo/lib/Photo/Controller/Album.pm}

Our template for this action (album/show.html.ep) does several things. In the
HTML body we have our error handling, form to handle a new photo upload, button
that allows for switching between albums, and the picture viewing code.  

The picture code is in the template twice.  The first time is if there are no
photos to view and the second is when we have a photo.

The form code is shown below.

\lstinputlisting[basicstyle=\LSTfont, language=Html, firstline=38, lastline=67]{photo/templates/album/show.html.ep}

At line \ref{_form_start} we specify action that will happen when we upload a
file.  Line \ref{_form_object} is pretty cool because we're accessing a value in
the stash that is an object.  Lines 13 to 15 process our album array to
generate a pulldown for the user to select an album.  They are shown below.

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Html, firstline=50, lastline=52]{photo/templates/album/show.html.ep}

The ability to intermix perl loop and control structures with plain html is
very powerful. As a specific example, the above allows us to iterate over an 
array of objects in the stash to create a portion of our html document.

After our form, we process the HTML to display the album.  This is shown below.

\begin{lstlisting}[language=Html, style=BlockStyle]
    % if (0 == @{ stash('slots') }) {
        <div class="row">
            <div class="span12">
                No photos found
            </div>
        </div>
    % }

    % if (0 != @{ stash('slots') }) {
    ...
    % }
\end{lstlisting}

Note that there are two sections.  One is for when there is no photos in the album
and the other is for when there are.  The code for when there are photos is much
more interesting than when there aren't, so lets look at a few snippets from it:

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Html, firstline=87, lastline=90]{photo/templates/album/show.html.ep}

This snippet processes our album array and is used to give us a 'lil dot to click on
to maneuver through the pics.  Of note is how the \$active variable is used to populate
our class.

\lstinputlisting[basicstyle=\LSTfont, language=Html, firstline=93, lastline=108]{photo/templates/album/show.html.ep}

The next snippet displays the pictures. The line at \ref{_form_url_for} provides the 
src for the img tag. Without it, it would be difficult to have pictures.

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Html, firstline=110, lastline=113]{photo/templates/album/show.html.ep}

Finally, we the left and right arrows over the image if there is more than photo.

Ok!  We've done a lot and have a bit more to go.  We should talk about the file upload
and img src tag routes.  Below is the form code that will POST to our upload route.

\lstinputlisting[basicstyle=\LSTfont, numbers=none, language=Html, firstline=38, lastline=38]{photo/templates/album/show.html.ep}

The upload action is this sub: Photo::Controller::Album::upload.  This does
some validation, creates a photo album object, and then stores the photo in a
new "slot".  A slot is merely a way to refer to a set of pictures.  Each slot
is comprised of two files, one being the metadata for the image (a JSON file)
and the other being the image itself.

The img src tag route, which is the Photo::Controller::Album::photo sub is shown below.

\lstinputlisting[basicstyle=\LSTfont, language=Perl, firstline=131, lastline=142]{photo/lib/Photo/Controller/Album.pm}

This retrieves our selected album, gets the photo in a particular slot, and
then sets our reply to use that file. At line \ref{_photo_session} is where the
album object is created - this shows one way to access session variables. The slot
is given to us from the template and \ref{_photo_filename} gets the filename
for the photo in that slot.  It's an absolute path.

This path is then served at line \ref{_photo_reply}.

The last bit of code is used to manually switch to a different album. It's main utility
is when the session expires and the user has to choose an album, again.  The code is
below.

\lstinputlisting[basicstyle=\LSTfont, language=Perl, firstline=60, lastline=78]{photo/lib/Photo/Controller/Album.pm}

If we've been given a name from the view, then we save the album name in the session and
redirect back to the landing page.  This should then do another redirect back to the
album viewer.

\end{document}
